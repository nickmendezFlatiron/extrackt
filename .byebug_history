exit
params.keys[0..-4]
continue
p
continue
p
continue
search["key"]
search[:key]
search[p] = p
p
exit
search
res
exit
session[:user_id]
current_user
params[:user_id]
c.user_id
c = Collection.find(params[:id])
params[:id]
exit
params
params[:id]
exit
res = [*recent , *popular]
res
res = [*recent]
recent
res = [**recent]
exit
params
exit
recent
exit
popular
recent
exit
rails_blob_path(self.object.audio_file)
rails_blob_path(object.audio_file)
rails_blob_path(object.audi_file)
Rails.application.routes.url_helpers.rails_blob_path(self.object.audio_file, only_path: true)
continue
exit
Rails.application.routes.url_helpers.rails_blob_path(self.object.audio_file, only_path: true)
continue
Rails.application.routes.url_helpers.rails_blob_path(self.object.audio_file, only_path: true)
exit
self.object.audio_file.attached?
rails_blob_path(self.object.audio_file, disposition: "attachment")
self.object.audio_file
url_for(self.object.audio_file)
self.object.audio_file
self
Rails.application.routes.url_helpers.rails_blob_path(self.object.audio_file, only_path: true)
continue
exit
Rails.application.routes.url_helpers.rails_info_path(Sample.first.audio_file)
Rails.application.routes.url_helpers.rails_blob_path(Sample.first.audio_file)
Sample.first.audio_file
Sample.first
ans.to_json
ans
exit
exot
exit
ans.to_json
ans
exit
exi
ans
exit
ans
exit
ans
exit
Sample.find_all(search)
search
ans
asns
test_case
exit
ans.empty?
ans == nil
ans
exit
ans
exit
r
test_case
exit
res
params["key"]
e
r
test_case
next
test_case
exit
ans
test_case
exit
["test",1,3,4].include?("test") 
ans
exit
res.map do |r|
        test = params["key"].all? {|value| r["key"].include?(value)}
        if test
          return r
        end
        \
res.map do |r|
        test = params["key"].all? {|value| r["key"].include?(value)}
        if test
          return r
        end
        next   
      end
ans
exit
ans = res.map do |r|
        test = params["key"].all? {|value| r["key"].include?(value)}
        if test
          return res
        else
          next
        end
      end
!params["key"].empty?
exit
test
ans
res
exit
res
ans
exit
res.each do |r| puts "p" end
res
!params["key"].empty?
params["key"].empty?
params["key"]
params["key"] == true
params.key == true
res.count
res
exit
params["key"]
search
exit
search["key"] == nil
search["key] 
search["key] == nil?
search["key] == nil
search
exit
params.keys[0..-4]
params.keys[1..-4]
params[0..-4]
params[1..-4]
params
exit
params.keys[0..-4]
params.keys[0..-3]
params.keys[1..-3]
params.keys[1..-4]
params[1]
params
params[1..4]
params[1..params.keys.length-4]
params.length
params[1..params.length-4]
params
params[1..-4]
params
exit
Sample.first
params.keys[1..-4]
params.keys[1..-4].each do |p| puts "p" end
params.keys[1..-3].each do |p| puts "p" end
params[1..-3].each do |p| puts "p" end
params.each do |p| puts "p" end
params
exit
params
exit
params
continue
params
exit
params
continue
params.keys[1..-3]
params.keys
len
params[1..len]
params[1..-3]
params
params[1..-3].each do |p| puts "p" end
exit
JSON.parse(params[p][:key])
params[p][:key]
params[p]
p
exit
keys[1..len]
len
keys
exit
params[:p]
params[:p][:key]
JSON.parse(params[:p][:key]
exit
exot
params.keys[1..1].each do |p| puts "orint" end
params.keys[1..1].each do |p|
params.keys[1..1]
len
exit
!!
exit
params[:pad1][:name]
params[:pad1]
params.keys[1..len-3].each {|p| puts "test"}
params.keys[0..len-3].each {|p| puts "test"}
params.keys[0..len-2].each {|p| puts "test"}
params.keys[0..len].each {|p| puts "test"}
len = params.keys.length
params.keys.length
param.keys.length
par = params.pop()
par = params.pop
par = params[0..-3]
par = params.length
p
params
p
p = params.slice(0 , -1)
p = params.splice(0 , -1)
params.each{|p| puts "p"}
params[:pad1]
params[:collection]
params
exit
params.count
params
params.length
params
params[:sample]
params[:collection].name
params[:collection][:name]
params["collection"][:name]
params["collection"]
params["collection']
params["collection'}
params
